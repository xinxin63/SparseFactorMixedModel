microbenchmark(#
                sample_MME_ZAZts(Y_tilde, Z_all, tot_Y_prec, prior_mean, randomEffect_C_Choleskys, resid_h2, resid_h2_index,chol_Ai_mats,ncores),#
                sample_MME_ZAZts_2(Y_tilde, Z_all, tot_Y_prec, prior_mean, randomEffect_C_Choleskys, resid_h2, resid_h2_index,chol_Ai_mats,ncores))
prior_mean = matrix(0,sum(r_RE),p)
microbenchmark(
sample_MME_ZAZts(Y_tilde, Z_all, tot_Y_prec, prior_mean, randomEffect_C_Choleskys, resid_h2, resid_h2_index,chol_Ai_mats,ncores),
sample_MME_ZAZts_2(Y_tilde, Z_all, tot_Y_prec, prior_mean, randomEffect_C_Choleskys, resid_h2, resid_h2_index,chol_Ai_mats,ncores))
is(Y_tilde)
Q
library(parallel)#
library(Rcpp)#
library(Matrix)#
library(microbenchmark)#
compiler::enableJIT(3)#
# # compiler::setCompilerOptions(optimize=3)#
compiler::setCompilerOptions(suppressAll=TRUE)#
#
# setwd("~/Runcie Lab/SparseFactorMixedModel/R_BSFG")#
model_path = '~/Box Sync/DER_projects/BSFG/R_BSFG'#
# model_path = "/home/deruncie/projects/BSFG_Correction/software"#
# model_path = "~/Runcie Lab/SparseFactorMixedModel/R_BSFG"#
source(paste(model_path,'BSFG_discreteRandom_init.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
# source(paste(model_path,'BSFG_discreteRandom_sampler_2.R',sep='/'))#
# source(paste(model_path,'BSFG_discreteRandom_functions_v2.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
source(paste(model_path,'plotting_diagnostics.R',sep='/'))#
#
sourceCpp(paste(model_path,'BSFG_discreteRandom_functions_c.cpp',sep='/')) #,cacheDir = model_path
library(parallel)#
library(Rcpp)#
library(Matrix)#
library(microbenchmark)#
compiler::enableJIT(3)#
# # compiler::setCompilerOptions(optimize=3)#
compiler::setCompilerOptions(suppressAll=TRUE)#
#
# setwd("~/Runcie Lab/SparseFactorMixedModel/R_BSFG")#
model_path = '~/Box Sync/DER_projects/BSFG/R_BSFG'#
# model_path = "/home/deruncie/projects/BSFG_Correction/software"#
# model_path = "~/Runcie Lab/SparseFactorMixedModel/R_BSFG"#
source(paste(model_path,'BSFG_discreteRandom_init.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
# source(paste(model_path,'BSFG_discreteRandom_sampler_2.R',sep='/'))#
# source(paste(model_path,'BSFG_discreteRandom_functions_v2.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
source(paste(model_path,'plotting_diagnostics.R',sep='/'))#
#
sourceCpp(paste(model_path,'BSFG_discreteRandom_functions_c.cpp',sep='/')) #,cacheDir = model_path
print('Initializing')#
setup = BSFG_discreteRandom_loadData()#
BSFG_state = with(setup,BSFG_discreteRandom_init(Y, ~1, ~Group,randomEffects,data,priors,run_parameters,scaleY = F,simulation = T))#
BSFG_state$run_parameters$setup = setup$setup#
#
library(MCMCpack)#
discrete_divisions = run_parameters$discrete_divisions#
BSFG_state$priors$Resid_discrete_priors = with(BSFG_state$data_matrices, sapply(1:ncol(h2_divisions),function(x) {#
    h2s = h2_divisions[,x]#
    pmax(pmin(ddirichlet(c(h2s,1-sum(h2s)),rep(2,length(h2s)+1)),10),1e-10)#
}))#
BSFG_state$priors$Resid_discrete_priors = BSFG_state$priors$Resid_discrete_priors/sum(BSFG_state$priors$Resid_discrete_priors)#
BSFG_state$priors$F_discrete_priors = c(discrete_divisions-1,rep(1,discrete_divisions-1))/(2*(discrete_divisions-1))#
#
# BSFG_state$priors$F_discrete_priors = with(BSFG_state$data_matrices, sapply(1:nrow(h2_divisions),function(x) {#
#     h2s = h2_divisions[x,]#
#     pmax(pmin(ddirichlet(c(h2s,1-sum(h2s)),rep(2,length(h2s)+1)),10),1e-10)#
# }))#
#
save(BSFG_state,file="BSFG_state.RData")#
#
BSFG_state = clear_Posterior(BSFG_state)#
# # optional: To load from end of previous run, run above code, then run these lines:#
# load('Posterior.RData')#
# load('BSFG_state.RData')#
# load('Priors.RData')#
#  BSFG_state$current_state = current_state#
#  BSFG_state$Posterior = Posterior#
#  BSFG_state$priors = priors#
# start_i = run_parameters$nrun;#
#
# Run Gibbs sampler. Run in smallish chunks. Output can be used to re-start chain where it left off.#
# burn in#
#
# if(run_parameters$burn > 0) BSFG_state = fast_BSFG_sampler(BSFG_state,run_parameters$burn)#
# BSFG_discreteRandom_sampler_2c = compiler::cmpfun(BSFG_discreteRandom_sampler)#
n_samples = 100;#
for(i  in 1:70) {#
    print(sprintf('Run %d',i))#
    # microbenchmark(#
    #     BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,8),#
    #     BSFG_discreteRandom_sampler(BSFG_state,n_samples,8),#
    #     BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,1),#
    #     BSFG_discreteRandom_sampler(BSFG_state,n_samples,1),#
    #     times = 10#
    #     )#
    # BSFG_state2 = BSFG_discreteRandom_sampler(BSFG_state,n_samples,8)#
    # BSFG_state2 = BSFG_discreteRandom_sampler_2c(BSFG_state,n_samples,8)#
    BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,1)#
    # BSFG_state2 = BSFG_discreteRandom_sampler_2c(BSFG_state,n_samples,1)#
    dev.set(6)#
    try({#
        par(mfrow=c(2,2))#
        plot(BSFG_state$Posterior$delta[1,],ylim = c(0,max(BSFG_state$Posterior$delta[1,])),type='l')#
        plot(BSFG_state$Posterior$delta[2,],ylim = c(0,max(BSFG_state$Posterior$delta[2,])),type='l')#
        plot(BSFG_state$Posterior$delta[3,],ylim = c(0,max(BSFG_state$Posterior$delta[3,])),type='l')#
    })#
    BSFG_state = reorder_factors(BSFG_state)#
    # if(BSFG_state$simulation) {#
        draw_simulation_diagnostics(BSFG_state)#
    # } else{#
    #     draw_results_diagnostics(BSFG_state)#
    # }#
    print(i)#
}
print(sprintf('Run %d',i))#
    microbenchmark(#
        # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,8),#
        BSFG_discreteRandom_sampler(BSFG_state,n_samples,8),#
        # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,1),#
        BSFG_discreteRandom_sampler(BSFG_state,n_samples,1),#
        times = 10#
        )
n_samples = 10;
n_samples = 2;
microbenchmark(#
        # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,8),#
        BSFG_discreteRandom_sampler(BSFG_state,n_samples,8),#
        # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,1),#
        BSFG_discreteRandom_sampler(BSFG_state,n_samples,1),#
        times = 10#
        )
n_samples = 100;#
for(i  in 1:70) {#
    print(sprintf('Run %d',i))#
    # microbenchmark(#
    #     # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,8),#
    #     BSFG_discreteRandom_sampler(BSFG_state,n_samples,8),#
    #     # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,1),#
    #     BSFG_discreteRandom_sampler(BSFG_state,n_samples,1),#
    #     times = 10#
    #     )#
    # BSFG_state2 = BSFG_discreteRandom_sampler(BSFG_state,n_samples,8)#
    # BSFG_state2 = BSFG_discreteRandom_sampler_2c(BSFG_state,n_samples,8)#
    BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,1)#
    # BSFG_state2 = BSFG_discreteRandom_sampler_2c(BSFG_state,n_samples,1)#
    dev.set(6)#
    try({#
        par(mfrow=c(2,2))#
        plot(BSFG_state$Posterior$delta[1,],ylim = c(0,max(BSFG_state$Posterior$delta[1,])),type='l')#
        plot(BSFG_state$Posterior$delta[2,],ylim = c(0,max(BSFG_state$Posterior$delta[2,])),type='l')#
        plot(BSFG_state$Posterior$delta[3,],ylim = c(0,max(BSFG_state$Posterior$delta[3,])),type='l')#
    })#
    BSFG_state = reorder_factors(BSFG_state)#
    # if(BSFG_state$simulation) {#
        draw_simulation_diagnostics(BSFG_state)#
    # } else{#
    #     draw_results_diagnostics(BSFG_state)#
    # }#
    print(i)#
}
setd('../../Sim_11/')
setwd('../../Sim_11/')
# choose a seed for the random number generator. This can be a random seed (for analysis), or you can choose your seed so that #
# you can repeat the MCMC exactly#
seed = 1#
set.seed(seed)#
#
# create a folder for holding the posterior samples of the current chain (multiple folders could be used for different chains)#
rep = "3"#
folder = sprintf('R_rep_%s',rep)#
try(dir.create(folder))#
setwd(folder)#
# initialize priors#
run_parameters = list(#
    b0           = 1,#
    b1           = 0.0005,#
    epsilon      = 1e-1,#
    prop         = 1.00,#
    # h2_divisions = 100,#
    discrete_divisions = 100,#
    save_freq    = 100,#
    burn = 100,       #100#
    thin = 2         #2#
    )#
#
#load("./priors.RData")#
priors = list(#
    k_init              =   20,#
    # resid_Y_prec_shape  =   2,#
    # resid_Y_prec_rate   =   1/10,#
    # E_a_prec_shape      =   2,#
    # E_a_prec_rate       =   1/10,#
    # F_a_prec_shape      =   2,#
    # F_a_prec_rate       =   1/10,#
    # F_e_prec_shape      =   2,#
    # F_e_prec_rate       =   1/10,#
    # tot_Y_prec_shape      =   2,#
    # tot_Y_prec_rate       =   1/2,#
    tot_Y_prec_shape      =   2.4,#
    tot_Y_prec_rate       =   1/3.5,#
    tot_F_prec_shape      =   20,#
    tot_F_prec_rate       =   21,#
    # tot_F_prec_shape      =   2+250/2,#
    # tot_F_prec_rate       =   1+250/2,#
    Lambda_df           =   3,         # 3/2, 3, 1#
    delta_1_shape       =   2,#
    delta_1_rate        =   1/20,#
    delta_2_shape       =   2,           # 3, 3/2, 9/2#
    delta_2_rate        =   1#
)#
#
print('Initializing')#
setup = BSFG_discreteRandom_loadData()#
BSFG_state = with(setup,BSFG_discreteRandom_init(Y, ~1, ~Group,randomEffects,data,priors,run_parameters,scaleY = F,simulation = T))#
BSFG_state$run_parameters$setup = setup$setup#
#
library(MCMCpack)#
discrete_divisions = run_parameters$discrete_divisions#
BSFG_state$priors$Resid_discrete_priors = with(BSFG_state$data_matrices, sapply(1:ncol(h2_divisions),function(x) {#
    h2s = h2_divisions[,x]#
    pmax(pmin(ddirichlet(c(h2s,1-sum(h2s)),rep(2,length(h2s)+1)),10),1e-10)#
}))#
BSFG_state$priors$Resid_discrete_priors = BSFG_state$priors$Resid_discrete_priors/sum(BSFG_state$priors$Resid_discrete_priors)#
BSFG_state$priors$F_discrete_priors = c(discrete_divisions-1,rep(1,discrete_divisions-1))/(2*(discrete_divisions-1))#
#
# BSFG_state$priors$F_discrete_priors = with(BSFG_state$data_matrices, sapply(1:nrow(h2_divisions),function(x) {#
#     h2s = h2_divisions[x,]#
#     pmax(pmin(ddirichlet(c(h2s,1-sum(h2s)),rep(2,length(h2s)+1)),10),1e-10)#
# }))#
#
save(BSFG_state,file="BSFG_state.RData")#
#
BSFG_state = clear_Posterior(BSFG_state)#
# # optional: To load from end of previous run, run above code, then run these lines:#
# load('Posterior.RData')#
# load('BSFG_state.RData')#
# load('Priors.RData')#
#  BSFG_state$current_state = current_state#
#  BSFG_state$Posterior = Posterior#
#  BSFG_state$priors = priors#
# start_i = run_parameters$nrun;#
#
# Run Gibbs sampler. Run in smallish chunks. Output can be used to re-start chain where it left off.#
# burn in
n_samples=10
microbenchmark(#
        # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,8),#
        BSFG_discreteRandom_sampler(BSFG_state,n_samples,8),#
        # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,1),#
        BSFG_discreteRandom_sampler(BSFG_state,n_samples,1),#
        times = 10#
        )
n_samples=2
microbenchmark(#
        # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,8),#
        BSFG_discreteRandom_sampler(BSFG_state,n_samples,8),#
        # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,1),#
        BSFG_discreteRandom_sampler(BSFG_state,n_samples,1),#
        times = 10#
        )
# if(run_parameters$burn > 0) BSFG_state = fast_BSFG_sampler(BSFG_state,run_parameters$burn)#
# BSFG_discreteRandom_sampler_2c = compiler::cmpfun(BSFG_discreteRandom_sampler)#
n_samples = 100;#
for(i  in 1:70) {#
    print(sprintf('Run %d',i))#
    # microbenchmark(#
    #     # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,8),#
    #     BSFG_discreteRandom_sampler(BSFG_state,n_samples,8),#
    #     # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,1),#
    #     BSFG_discreteRandom_sampler(BSFG_state,n_samples,1),#
    #     times = 10#
    #     )#
    # BSFG_state2 = BSFG_discreteRandom_sampler(BSFG_state,n_samples,8)#
    # BSFG_state2 = BSFG_discreteRandom_sampler_2c(BSFG_state,n_samples,8)#
    BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,8)#
    # BSFG_state2 = BSFG_discreteRandom_sampler_2c(BSFG_state,n_samples,1)#
    dev.set(6)#
    try({#
        par(mfrow=c(2,2))#
        plot(BSFG_state$Posterior$delta[1,],ylim = c(0,max(BSFG_state$Posterior$delta[1,])),type='l')#
        plot(BSFG_state$Posterior$delta[2,],ylim = c(0,max(BSFG_state$Posterior$delta[2,])),type='l')#
        plot(BSFG_state$Posterior$delta[3,],ylim = c(0,max(BSFG_state$Posterior$delta[3,])),type='l')#
    })#
    BSFG_state = reorder_factors(BSFG_state)#
    # if(BSFG_state$simulation) {#
        draw_simulation_diagnostics(BSFG_state)#
    # } else{#
    #     draw_results_diagnostics(BSFG_state)#
    # }#
    print(i)#
}
BSFG_state = clear_Posterior(BSFG_state)#
# # optional: To load from end of previous run, run above code, then run these lines:#
# load('Posterior.RData')#
# load('BSFG_state.RData')#
# load('Priors.RData')#
#  BSFG_state$current_state = current_state#
#  BSFG_state$Posterior = Posterior#
#  BSFG_state$priors = priors#
# start_i = run_parameters$nrun;#
#
# Run Gibbs sampler. Run in smallish chunks. Output can be used to re-start chain where it left off.#
# burn in#
#
# if(run_parameters$burn > 0) BSFG_state = fast_BSFG_sampler(BSFG_state,run_parameters$burn)#
# BSFG_discreteRandom_sampler_2c = compiler::cmpfun(BSFG_discreteRandom_sampler)#
n_samples = 100;#
for(i  in 1:70) {#
    print(sprintf('Run %d',i))#
    # microbenchmark(#
    #     # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,8),#
    #     BSFG_discreteRandom_sampler(BSFG_state,n_samples,8),#
    #     # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,1),#
    #     BSFG_discreteRandom_sampler(BSFG_state,n_samples,1),#
    #     times = 10#
    #     )#
    # BSFG_state2 = BSFG_discreteRandom_sampler(BSFG_state,n_samples,8)#
    # BSFG_state2 = BSFG_discreteRandom_sampler_2c(BSFG_state,n_samples,8)#
    BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,8)#
    # BSFG_state2 = BSFG_discreteRandom_sampler_2c(BSFG_state,n_samples,1)#
    dev.set(6)#
    try({#
        par(mfrow=c(2,2))#
        plot(BSFG_state$Posterior$delta[1,],ylim = c(0,max(BSFG_state$Posterior$delta[1,])),type='l')#
        plot(BSFG_state$Posterior$delta[2,],ylim = c(0,max(BSFG_state$Posterior$delta[2,])),type='l')#
        plot(BSFG_state$Posterior$delta[3,],ylim = c(0,max(BSFG_state$Posterior$delta[3,])),type='l')#
    })#
    BSFG_state = reorder_factors(BSFG_state)#
    # if(BSFG_state$simulation) {#
        draw_simulation_diagnostics(BSFG_state)#
    # } else{#
    #     draw_results_diagnostics(BSFG_state)#
    # }#
    print(i)#
}
setwd("/Users/der7/Box Sync/DER_projects/BSFG/test_MM")
## This seems to be working now, with a decent speed up#
## It is all implemented using the perm-reducing re-ordering, which gives a good speed up to the fixed_effect sampling, #
##    and moderate speed-ups to the other two steps.#
## potentially strange results with limited discritization#
#
library(MCMCglmm)#
source('../R_BSFG/BSFG_discreteRandom_functions.R')#
Data <- as.data.frame(read.table(file = "./gryphon.dat", header = TRUE))#
names(Data)[1] <- "animal"#
Data$animal <- as.factor(Data$animal)#
Data$MOTHER <- as.factor(Data$MOTHER)#
Data$BYEAR <- as.factor(Data$BYEAR)#
Data$SEX <- as.factor(Data$SEX)#
Data$BWT <- as.numeric(Data$BWT)#
Data$TARSUS <- as.numeric(Data$TARSUS)#
head(Data)#
Ped <- as.data.frame(read.table(file = "./gryphon.ped", header = TRUE))#
for (x in 1:3) Ped[, x] <- as.factor(Ped[, x])#
head(Ped)
prior1.3 <- list(G = list(G1 = list(V = 1, n = 0.002), G2 = list(V = 1,n = 0.002)), R = list(V = 1, n = 0.002))#
prior1.3 = list(R = list(V = 1/3, nu = 3), G = list(G1 = list(V = 1/3,nu=3),G2 = list(V = 1/3,nu=3)))#
model1.3 <- MCMCglmm(BWT ~ SEX, random = ~animal + BYEAR, pedigree = Ped,#
    data = Data, nitt = 6500, thin = 5, burnin = 1500, prior = prior1.3,pr=T,#
    verbose = FALSE)#
posterior.mode(model1.3$VCV)#
#
mcmc_model = model1.3
discrete_divisions = 50#
priors = list(#
    tot_Y_prec_shape      =   2.4,#
    tot_Y_prec_rate       =   1/3.5#
)#
#
data = droplevels(subset(Data,!is.na(BWT)))#
data$animal = factor(as.character(data$animal),levels = data$animal)#
#
index = match(data$animal,Ped[,1])#
randomEffects = list(animal = forceSymmetric(inverseA(Ped)[[1]]))#
#
# build Z matrices from random model#
RE_names = c(names(randomEffects),'BYEAR')#
n_RE = length(RE_names)#
Z_matrices = lapply(RE_names,function(re) {#
    # Diagonal(r_RE[re],1)#
    Z = Matrix(model.matrix(formula(sprintf('~0 + %s',re)),data),sparse = TRUE)#
    Z[,paste0(re,levels(data[[re]]))]#
})#
names(Z_matrices) = RE_names#
r_RE = sapply(Z_matrices,function(x) ncol(x))#
# r_RE = sapply(RE_names,function(x) dim(randomEffects[[x]])[1])#
#
Z_all = do.call(cbind,Z_matrices)#
#
for(re in RE_names[RE_names %in% names(randomEffects) == F]){#
    randomEffects[[re]] = Diagonal(ncol(Z_matrices[[re]]),1)#
    rownames(randomEffects[[re]]) = levels(data[[re]])#
}#
fix_A = function(x) forceSymmetric(drop0(x,tol = 1e-10))#
#
A_mats = lapply(RE_names,function(re) {#
    A = solve(randomEffects[[re]])#
    index = match(sub(re,'',colnames(Z_matrices[[re]])),rownames(randomEffects[[re]]))#
    fix_A(A[index,index])#
})#
names(A_mats) = RE_names#
Ai_mats = lapply(A_mats,function(x) fix_A(solve(x)))#
chol_Ai_mats = lapply(Ai_mats,chol)#
#
h2_divisions = expand.grid(lapply(RE_names,function(re) 0:discrete_divisions)) / discrete_divisions#
colnames(h2_divisions) = RE_names#
h2_divisions = t(h2_divisions[rowSums(h2_divisions) < 1,,drop=FALSE])#
#
library(MCMCpack)#
priors$discrete_priors = sapply(1:ncol(h2_divisions),function(x) {#
    h2s = h2_divisions[,x]#
    pmax(pmin(ddirichlet(c(h2s,1-sum(h2s)),rep(2,length(h2s)+1)),10),1e-10)#
})/100#
ZAZts = list()#
for(i in 1:n_RE){#
    ZAZts[[i]] = forceSymmetric(Z_matrices[[i]] %*% A_mats[[i]] %*% t(Z_matrices[[i]]))#
}#
#
#C#
ZtZ = crossprod(Z_all)#
make_Ai = function(Ai_mats,h2s) {#
    do.call(bdiag,lapply(1:length(h2s),function(j) {#
        if(h2s[j] == 0) {  # if h2==0, then we want a Diagonal matrix with Inf diagonal. This will allow Cinv = 0#
            Diagonal(nrow(Ai_mats[[j]]),Inf)#
        } else{#
            Ai_mats[[j]]/h2s[j]  #
        }#
    }))#
}#
#
make_Chol_Ai = function(chol_Ai_mats,h2s){#
    do.call(bdiag,lapply(1:length(h2s),function(i) {#
        if(h2s[i] == 0) return(Diagonal(nrow(chol_Ai_mats[[i]]),Inf))  # if h2==0, then we want a Diagonal matrix with Inf diagonal.#
        chol_Ai = chol_Ai_mats[[i]]#
        chol_Ai@x = chol_Ai@x / sqrt(h2s[i])#
        chol_Ai#
    }))#
}#
# setup of symbolic Cholesky of C#
Ai = forceSymmetric(make_Ai(Ai_mats,rep(1,n_RE)/(n_RE+1)))#
Cholesky_C = Cholesky(ZtZ + Ai)#
#
randomEffect_C_Choleskys = mclapply(1:ncol(h2_divisions),function(i) {      #
    if(i %% 100 == 0) print(i)#
    h2s = h2_divisions[,i]#
    Ai = make_Ai(Ai_mats,h2s)#
    C = ZtZ/(1-sum(h2s))#
    C = C + Ai#
    Cholesky_C_i = update(Cholesky_C,forceSymmetric(C))#
    chol_A_inv = make_Chol_Ai(chol_Ai_mats,h2s)#
#
},mc.cores = ncores)#
#
# Sigma#
make_Sigma = function(ZAZts,h2s){#
    R = 0#
    for(i in 1:length(h2s)){#
        R = R + h2s[i]*ZAZts[[i]]#
    }#
    forceSymmetric(R + (1-sum(h2s)) * Diagonal(nrow(R)))#
}#
#
# setup of symbolic Cholesky of Sigma#
Sigma = make_Sigma(ZAZts,h2_divisions[,2])#
Cholesky_Sigma_base = Cholesky(Sigma,perm=T,super=T)#
# Cholesky_Sigma_base = Cholesky(Sigma,LDL=F,perm=T)#
Sigma_Perm = expand(Cholesky_Sigma_base)$P#
if(all(diag(Sigma_Perm))) Sigma_Perm = NULL#
#
Sigma_Choleskys = lapply(1:ncol(h2_divisions),function(i) {#
    if(i %% 100 == 0) print(i)#
    Sigma = forceSymmetric(make_Sigma(ZAZts,h2_divisions[,i]))#
    stopifnot(class(Sigma) == 'dsCMatrix')#
    Cholesky_Sigma = update(Cholesky_Sigma_base,Sigma)#
    log_det = 2*determinant(Cholesky_Sigma,logarithm=T)$modulus#
    if(is.null(Sigma_Perm)) {#
        chol_Sigma = expand(Cholesky_Sigma)$L#
    } else{#
        chol_Sigma = t(Sigma_Perm) %*% expand(Cholesky_Sigma)$L#
    }#
    list(log_det = log_det,Cholesky_Sigma = Cholesky_Sigma,chol_Sigma=chol_Sigma)#
})#
Y = as.matrix(data[,'BWT',drop=F])#
fixed = formula(~SEX)#
#
# build X from fixed model#
X = model.matrix(fixed,data)#
b = ncol(X)#
p=1#
#
tot_Y_prec = with(priors,rgamma(1,shape = tot_Y_prec_shape,rate = tot_Y_prec_rate))#
tot_Y_prec = .13#
#
h2_index = sample(1:ncol(h2_divisions),1,replace=T)#
h2_index = 40#
h2 = h2_divisions[,h2_index,drop=FALSE]#
a = do.call(rbind,lapply(RE_names,function(effect){#
    rnorm(r_RE[effect], 0, sqrt(h2[effect,] / tot_Y_prec))#
}))#
#
B = rnorm(b)#
B = c(6,2.4)#
#
nIter = 500#
burn = 50#
thin = 1#
#
posterior = c();#matrix(NA,nrow = (nIter-burn)/thin,ncol = length(B)+length(h2)+1)#
as = c()#
sp = 0#
start = Sys.time()#
for(i in 1:nIter){#
    if(i %% 100 == 0) print(i)#
#
    Design = X#
    rows = b#
    prior_meanB = matrix(0,rows,p)#
    prior_precB = matrix(rep(1e-10,b),nc=1)#
    prior_precB = matrix(rep(0,b),nc=1)#
    # recover()#
    B = sample_MME_fixedEffects(Y,Design,Sigma_Choleskys, Sigma_Perm,  h2_index, tot_Y_prec, prior_meanB, prior_precB,1)#
#
    Y_tilde = as.matrix(Y - X %*% B)#
    tot_Y_prec = sample_tot_prec(Y_tilde, priors$tot_Y_prec_shape, priors$tot_Y_prec_rate, Sigma_Choleskys, Sigma_Perm,  h2_index,1)#
    h2_index = sample_h2s_discrete(Y_tilde,tot_Y_prec, Sigma_Choleskys, Sigma_Perm, priors$discrete_priors,8)#
    # h2_index = sample_h2s_discrete_MH(Y_tilde,tot_Y_prec, Sigma_Choleskys,Sigma_Perm, priors$discrete_priors,h2_divisions,h2_index,step_size = 0.02,ncores=1)#
    h2 = h2_divisions[,h2_index,drop=FALSE]#
    # a_prec = tot_Y_prec / colSums(h2)#
#
    # prior_meanA = matrix(0,ncol(Z_all),p)#
    # a = sample_MME_ZAZts(Y_tilde, Z_all, tot_Y_prec, prior_meanA, randomEffect_C_Choleskys, h2, h2_index,chol_Ai_mats,1)#
    # a = sapply(1:1000,function(x) sample_MME_ZAZts_inv(Y_tilde, Z_all, tot_Y_prec, prior_meanA, randomEffect_C_Choleskys, h2, h2_index,chol_Ai_mats,1))   #
    # a = a[1:nrow(A_mats[[1]]),]#
    # i = sample(1:nrow(a)^2,10000)#
    # plot(cov(t(as.matrix(a)))[i],as.matrix(A_mats[[1]])[i])#
    # as = cbind(as,a)#
#
    if((i > burn) & (i-burn)%%thin == 0){#
        sp = sp + 1#
        posterior = rbind(posterior,c(B, h2/tot_Y_prec, (1-sum(h2))/tot_Y_prec,h2))#
    }#
#
}#
Sys.time()-start#
#
boxplot(posterior)#
boxplot(cbind(mcmc_model$Sol[,1:2],mcmc_model$VCV))#
effectiveSize(posterior[1:sp,])#
effectiveSize(cbind(mcmc_model$Sol[,1:2],mcmc_model$VCV))#
i=2;qqplot(posterior[,i],mcmc_model$Sol[,i]);abline(0,1)#
i=1;qqplot(posterior[,2+i],mcmc_model$VCV[,i]);abline(0,1)#
i=2;qqplot(posterior[,2+i],mcmc_model$VCV[,i]);abline(0,1)#
i=3;qqplot(posterior[,2+i],mcmc_model$VCV[,i]);abline(0,1)#
#
for(i in 1:ncol(posterior)) plot(posterior[,i],type='l',main = i)#
#
microbenchmark(#
    sample_MME_fixedEffects_inv(Y,Design,Sigma_invs, h2_index, tot_Y_prec, prior_meanB, prior_precB,1),#
    sample_MME_fixedEffects_inv_v2(as.matrix(Y),Design,Sigma_Choleskys, Sigma_Perm,  h2_index, tot_Y_prec, prior_meanB, prior_precB,1),#
    sample_MME_ZAZts_inv(Y_tilde, Z_all, tot_Y_prec, prior_meanA, randomEffect_C_Choleskys, h2, h2_index,chol_As,1)#
    )#
#
microbenchmark(#
    sample_tot_prec_inv(Y_tilde, priors$tot_Y_prec_shape, priors$tot_Y_prec_rate, Sigma_invs, h2_index,1),#
    sample_tot_prec_inv_v2(Y_tilde, priors$tot_Y_prec_shape, priors$tot_Y_prec_rate, Sigma_Choleskys, Sigma_Perm,  h2_index,1)#
    )#
#
microbenchmark(#
    sample_h2s_discrete_inv(Y_tilde,tot_Y_prec, Sigma_invs,priors$discrete_priors,1),#
    sample_h2s_discrete_inv_v2(Y_tilde,tot_Y_prec, Sigma_Choleskys, Sigma_Perm, priors$discrete_priors,1)#
    )#
#
microbenchmark(#
    sample_h2s_discrete_inv_v2(Y_tilde,tot_Y_prec, Sigma_Choleskys, Sigma_Perm, priors$discrete_priors,1),#
    sample_h2s_discrete_inv_v2(Y_tilde,tot_Y_prec, Sigma_Choleskys, Sigma_Perm, priors$discrete_priors,8)#
    ,times=10)#
#
Ymat = matrix(Y,nrow = nrow(Y),nc = 100)#
#
microbenchmark(#
    sample_h2s_discrete_inv_v2(Ymat,tot_Y_prec, Sigma_Choleskys, Sigma_Perm, priors$discrete_priors,8),#
    sample_h2s_discrete_MH(Ymat,rep(tot_Y_prec,ncol(Ymat)), Sigma_Choleskys,Sigma_Perm, priors$discrete_priors,h2_divisions,rep(h2_index,ncol(Ymat)),step_size = 0.02,ncores=1)#
    ,times = 2)
make_Chol_Ai = function(chol_Ai_mats,h2s){#
    do.call(bdiag,lapply(1:length(h2s),function(i) {#
        if(h2s[i] == 0) return(Diagonal(nrow(chol_Ai_mats[[i]]),Inf))  # if h2==0, then we want a Diagonal matrix with Inf diagonal.#
        chol_Ai = chol_Ai_mats[[i]]#
        chol_Ai@x = chol_Ai@x / sqrt(h2s[i])#
        chol_Ai#
    }))#
}#
# setup of symbolic Cholesky of C#
Ai = forceSymmetric(make_Ai(Ai_mats,rep(1,n_RE)/(n_RE+1)))#
Cholesky_C = Cholesky(ZtZ + Ai)#
#
randomEffect_C_Choleskys = lapply(1:ncol(h2_divisions),function(i) {        #
    if(i %% 100 == 0) print(i)#
    h2s = h2_divisions[,i]#
    Ai = make_Ai(Ai_mats,h2s)#
    C = ZtZ/(1-sum(h2s))#
    C = C + Ai#
    Cholesky_C_i = update(Cholesky_C,forceSymmetric(C))#
    chol_A_inv = make_Chol_Ai(chol_Ai_mats,h2s)#
#
})
discrete_divisions = 15#
priors = list(#
    tot_Y_prec_shape      =   2.4,#
    tot_Y_prec_rate       =   1/3.5#
)#
#
data = droplevels(subset(Data,!is.na(BWT)))#
data$animal = factor(as.character(data$animal),levels = data$animal)#
#
index = match(data$animal,Ped[,1])#
randomEffects = list(animal = forceSymmetric(inverseA(Ped)[[1]]))#
#
# build Z matrices from random model#
RE_names = c(names(randomEffects),'BYEAR')#
n_RE = length(RE_names)#
Z_matrices = lapply(RE_names,function(re) {#
    # Diagonal(r_RE[re],1)#
    Z = Matrix(model.matrix(formula(sprintf('~0 + %s',re)),data),sparse = TRUE)#
    Z[,paste0(re,levels(data[[re]]))]#
})#
names(Z_matrices) = RE_names#
r_RE = sapply(Z_matrices,function(x) ncol(x))#
# r_RE = sapply(RE_names,function(x) dim(randomEffects[[x]])[1])#
#
Z_all = do.call(cbind,Z_matrices)#
#
for(re in RE_names[RE_names %in% names(randomEffects) == F]){#
    randomEffects[[re]] = Diagonal(ncol(Z_matrices[[re]]),1)#
    rownames(randomEffects[[re]]) = levels(data[[re]])#
}#
fix_A = function(x) forceSymmetric(drop0(x,tol = 1e-10))#
#
A_mats = lapply(RE_names,function(re) {#
    A = solve(randomEffects[[re]])#
    index = match(sub(re,'',colnames(Z_matrices[[re]])),rownames(randomEffects[[re]]))#
    fix_A(A[index,index])#
})#
names(A_mats) = RE_names#
Ai_mats = lapply(A_mats,function(x) fix_A(solve(x)))#
chol_Ai_mats = lapply(Ai_mats,chol)#
#
h2_divisions = expand.grid(lapply(RE_names,function(re) 0:discrete_divisions)) / discrete_divisions#
colnames(h2_divisions) = RE_names#
h2_divisions = t(h2_divisions[rowSums(h2_divisions) < 1,,drop=FALSE])
dim(h2_divisions)
library(MCMCpack)#
priors$discrete_priors = sapply(1:ncol(h2_divisions),function(x) {#
    h2s = h2_divisions[,x]#
    pmax(pmin(ddirichlet(c(h2s,1-sum(h2s)),rep(2,length(h2s)+1)),10),1e-10)#
})/100#
ZAZts = list()#
for(i in 1:n_RE){#
    ZAZts[[i]] = forceSymmetric(Z_matrices[[i]] %*% A_mats[[i]] %*% t(Z_matrices[[i]]))#
}#
#
#C#
ZtZ = crossprod(Z_all)#
make_Ai = function(Ai_mats,h2s) {#
    do.call(bdiag,lapply(1:length(h2s),function(j) {#
        if(h2s[j] == 0) {  # if h2==0, then we want a Diagonal matrix with Inf diagonal. This will allow Cinv = 0#
            Diagonal(nrow(Ai_mats[[j]]),Inf)#
        } else{#
            Ai_mats[[j]]/h2s[j]  #
        }#
    }))#
}#
#
make_Chol_Ai = function(chol_Ai_mats,h2s){#
    do.call(bdiag,lapply(1:length(h2s),function(i) {#
        if(h2s[i] == 0) return(Diagonal(nrow(chol_Ai_mats[[i]]),Inf))  # if h2==0, then we want a Diagonal matrix with Inf diagonal.#
        chol_Ai = chol_Ai_mats[[i]]#
        chol_Ai@x = chol_Ai@x / sqrt(h2s[i])#
        chol_Ai#
    }))#
}#
# setup of symbolic Cholesky of C#
Ai = forceSymmetric(make_Ai(Ai_mats,rep(1,n_RE)/(n_RE+1)))#
Cholesky_C = Cholesky(ZtZ + Ai)#
#
randomEffect_C_Choleskys = lapply(1:ncol(h2_divisions),function(i) {        #
    if(i %% 100 == 0) print(i)#
    h2s = h2_divisions[,i]#
    Ai = make_Ai(Ai_mats,h2s)#
    C = ZtZ/(1-sum(h2s))#
    C = C + Ai#
    Cholesky_C_i = update(Cholesky_C,forceSymmetric(C))#
    chol_A_inv = make_Chol_Ai(chol_Ai_mats,h2s)#
#
})#
#
# Sigma#
make_Sigma = function(ZAZts,h2s){#
    R = 0#
    for(i in 1:length(h2s)){#
        R = R + h2s[i]*ZAZts[[i]]#
    }#
    forceSymmetric(R + (1-sum(h2s)) * Diagonal(nrow(R)))#
}#
#
# setup of symbolic Cholesky of Sigma#
Sigma = make_Sigma(ZAZts,h2_divisions[,2])#
Cholesky_Sigma_base = Cholesky(Sigma,perm=T,super=T)#
# Cholesky_Sigma_base = Cholesky(Sigma,LDL=F,perm=T)#
Sigma_Perm = expand(Cholesky_Sigma_base)$P#
if(all(diag(Sigma_Perm))) Sigma_Perm = NULL#
#
Sigma_Choleskys = lapply(1:ncol(h2_divisions),function(i) {#
    if(i %% 100 == 0) print(i)#
    Sigma = forceSymmetric(make_Sigma(ZAZts,h2_divisions[,i]))#
    stopifnot(class(Sigma) == 'dsCMatrix')#
    Cholesky_Sigma = update(Cholesky_Sigma_base,Sigma)#
    log_det = 2*determinant(Cholesky_Sigma,logarithm=T)$modulus#
    if(is.null(Sigma_Perm)) {#
        chol_Sigma = expand(Cholesky_Sigma)$L#
    } else{#
        chol_Sigma = t(Sigma_Perm) %*% expand(Cholesky_Sigma)$L#
    }#
    list(log_det = log_det,Cholesky_Sigma = Cholesky_Sigma,chol_Sigma=chol_Sigma)#
})#
Y = as.matrix(data[,'BWT',drop=F])#
fixed = formula(~SEX)#
#
# build X from fixed model#
X = model.matrix(fixed,data)#
b = ncol(X)#
p=1#
#
tot_Y_prec = with(priors,rgamma(1,shape = tot_Y_prec_shape,rate = tot_Y_prec_rate))#
tot_Y_prec = .13#
#
h2_index = sample(1:ncol(h2_divisions),1,replace=T)#
h2_index = 40#
h2 = h2_divisions[,h2_index,drop=FALSE]#
a = do.call(rbind,lapply(RE_names,function(effect){#
    rnorm(r_RE[effect], 0, sqrt(h2[effect,] / tot_Y_prec))#
}))#
#
B = rnorm(b)#
B = c(6,2.4)#
#
nIter = 500#
burn = 50#
thin = 1#
#
posterior = c();#matrix(NA,nrow = (nIter-burn)/thin,ncol = length(B)+length(h2)+1)#
as = c()#
sp = 0#
start = Sys.time()#
for(i in 1:nIter){#
    if(i %% 100 == 0) print(i)#
#
    Design = X#
    rows = b#
    prior_meanB = matrix(0,rows,p)#
    prior_precB = matrix(rep(1e-10,b),nc=1)#
    prior_precB = matrix(rep(0,b),nc=1)#
    # recover()#
    B = sample_MME_fixedEffects(Y,Design,Sigma_Choleskys, Sigma_Perm,  h2_index, tot_Y_prec, prior_meanB, prior_precB,1)#
#
    Y_tilde = as.matrix(Y - X %*% B)#
    tot_Y_prec = sample_tot_prec(Y_tilde, priors$tot_Y_prec_shape, priors$tot_Y_prec_rate, Sigma_Choleskys, Sigma_Perm,  h2_index,1)#
    h2_index = sample_h2s_discrete(Y_tilde,tot_Y_prec, Sigma_Choleskys, Sigma_Perm, priors$discrete_priors,8)#
    # h2_index = sample_h2s_discrete_MH(Y_tilde,tot_Y_prec, Sigma_Choleskys,Sigma_Perm, priors$discrete_priors,h2_divisions,h2_index,step_size = 0.02,ncores=1)#
    h2 = h2_divisions[,h2_index,drop=FALSE]#
    # a_prec = tot_Y_prec / colSums(h2)#
#
    # prior_meanA = matrix(0,ncol(Z_all),p)#
    # a = sample_MME_ZAZts(Y_tilde, Z_all, tot_Y_prec, prior_meanA, randomEffect_C_Choleskys, h2, h2_index,chol_Ai_mats,1)#
    # a = sapply(1:1000,function(x) sample_MME_ZAZts_inv(Y_tilde, Z_all, tot_Y_prec, prior_meanA, randomEffect_C_Choleskys, h2, h2_index,chol_Ai_mats,1))   #
    # a = a[1:nrow(A_mats[[1]]),]#
    # i = sample(1:nrow(a)^2,10000)#
    # plot(cov(t(as.matrix(a)))[i],as.matrix(A_mats[[1]])[i])#
    # as = cbind(as,a)#
#
    if((i > burn) & (i-burn)%%thin == 0){#
        sp = sp + 1#
        posterior = rbind(posterior,c(B, h2/tot_Y_prec, (1-sum(h2))/tot_Y_prec,h2))#
    }#
#
}#
Sys.time()-start#
#
boxplot(posterior)#
boxplot(cbind(mcmc_model$Sol[,1:2],mcmc_model$VCV))
y_resid_p
y_resid
prior_mean
prior_prec
Q
prior_precB = matrix(rep(1e-10,b),nc=1)
B = sample_MME_fixedEffects(Y,Design,Sigma_Choleskys, Sigma_Perm,  h2_index, tot_Y_prec, prior_meanB, prior_precB,1)
y_resid_p
R_Perm
!is.null(R_Perm)
y_resid_p = R_Perm %*% y_resid
is(y_resid_p)
is(y_resid)
Q
sample_MME_single_diagA = function(y, W, C, RinvSqW, prior_mean,prior_prec,Cholesky_R,chol_R,R_Perm,tot_Y_prec) {#
    # R is aZAZ + bI#
    #    then form chol_R#
    #    check whether solve(t(chol_Rinv),theta) or chol_R %*% theta is better.#
    # G is diagonal (fixed effect) - prior prec#
    # prior_prec must be > 0#
    n = length(y)#
    n_theta = length(prior_prec)#
    theta_star = prior_mean + rnorm(n_theta)/sqrt(prior_prec)#
    e_star = (chol_R) %*% rnorm(n) / sqrt(tot_Y_prec)#
    W_theta_star = W %*% theta_star#
    y_resid = y - W_theta_star - e_star@x#
    if(!is.null(R_Perm)) {#
        y_resid_p = R_Perm %*% y_resid#
    } else{#
        y_resid_p = y_resid#
    }#
    WtRinvy = crossprod(RinvSqW, solve(Cholesky_R,y_resid_p,'L')) * tot_Y_prec#
#
    theta_tilda = solve(C,WtRinvy)#
#
    theta = theta_tilda@x + theta_star#
    theta#
}
nIter = 500#
burn = 50#
thin = 1#
#
posterior = c();#matrix(NA,nrow = (nIter-burn)/thin,ncol = length(B)+length(h2)+1)#
as = c()#
sp = 0#
start = Sys.time()#
for(i in 1:nIter){#
    if(i %% 100 == 0) print(i)#
#
    Design = X#
    rows = b#
    prior_meanB = matrix(0,rows,p)#
    prior_precB = matrix(rep(1e-10,b),nc=1)#
    # prior_precB = matrix(rep(0,b),nc=1)#
    # recover()#
    B = sample_MME_fixedEffects(Y,Design,Sigma_Choleskys, Sigma_Perm,  h2_index, tot_Y_prec, prior_meanB, prior_precB,1)#
#
    Y_tilde = as.matrix(Y - X %*% B)#
    tot_Y_prec = sample_tot_prec(Y_tilde, priors$tot_Y_prec_shape, priors$tot_Y_prec_rate, Sigma_Choleskys, Sigma_Perm,  h2_index,1)#
    h2_index = sample_h2s_discrete(Y_tilde,tot_Y_prec, Sigma_Choleskys, Sigma_Perm, priors$discrete_priors,8)#
    # h2_index = sample_h2s_discrete_MH(Y_tilde,tot_Y_prec, Sigma_Choleskys,Sigma_Perm, priors$discrete_priors,h2_divisions,h2_index,step_size = 0.02,ncores=1)#
    h2 = h2_divisions[,h2_index,drop=FALSE]#
    # a_prec = tot_Y_prec / colSums(h2)#
#
    # prior_meanA = matrix(0,ncol(Z_all),p)#
    # a = sample_MME_ZAZts(Y_tilde, Z_all, tot_Y_prec, prior_meanA, randomEffect_C_Choleskys, h2, h2_index,chol_Ai_mats,1)#
    # a = sapply(1:1000,function(x) sample_MME_ZAZts_inv(Y_tilde, Z_all, tot_Y_prec, prior_meanA, randomEffect_C_Choleskys, h2, h2_index,chol_Ai_mats,1))   #
    # a = a[1:nrow(A_mats[[1]]),]#
    # i = sample(1:nrow(a)^2,10000)#
    # plot(cov(t(as.matrix(a)))[i],as.matrix(A_mats[[1]])[i])#
    # as = cbind(as,a)#
#
    if((i > burn) & (i-burn)%%thin == 0){#
        sp = sp + 1#
        posterior = rbind(posterior,c(B, h2/tot_Y_prec, (1-sum(h2))/tot_Y_prec,h2))#
    }#
#
}#
Sys.time()-start#
#
boxplot(posterior)#
boxplot(cbind(mcmc_model$Sol[,1:2],mcmc_model$VCV))
boxplot(posterior[,1:5])
boxplot(cbind(mcmc_model$Sol[,1:2],mcmc_model$VCV))
effectiveSize(posterior[1:sp,])
effectiveSize(cbind(mcmc_model$Sol[,1:2],mcmc_model$VCV))
i=2;qqplot(posterior[,i],mcmc_model$Sol[,i]);abline(0,1)#
i=1;qqplot(posterior[,2+i],mcmc_model$VCV[,i]);abline(0,1)#
i=2;qqplot(posterior[,2+i],mcmc_model$VCV[,i]);abline(0,1)#
i=3;qqplot(posterior[,2+i],mcmc_model$VCV[,i]);abline(0,1)
1/3.5/3.4
# initialize priors#
run_parameters = list(#
    b0                 = 1,#
    b1                 = 0.0005,#
    epsilon            = 1e-1,#
    prop               = 1.00,#
    k_init             = 20,#
    discrete_divisions = 100,#
    burn               = 100,       #
    thin               = 2         #
    )#
#
priors = list(#
    tot_Y_prec = list(nu = 3.4, V = 1/3.5/3.4),#
    tot_F_prec = list(shape = 20, rate = 21),#
    delta_1    = list(shape = 2, rate = 1/20),#
    delta_2    = list(shape = 2, rate = 1),#
    Lambda_df  =   3#
)
priors$tot_Y_prec_shape = with(priors$tot_Y_prec,nu-1)#
    priors$tot_Y_prec_rate = with(priors$tot_Y_prec,V*nu)
priors
1/3.5
V = 1/3.5/3.4
nu = 3.4
V*nu/(nu-2)
tot_F_prec = list(nu = 21, rate = 21/nu)
nu
rm('nu')
tot_F_prec = list(nu = 21, rate = 21/nu)
priors = list(
priors = list(#
    tot_Y_prec = list(nu = 3.4, V = 1/3.5/3.4),#
    tot_F_prec = list(nu = 21, V = 21/21),#
    delta_1    = list(shape = 2, rate = 1/20),#
    delta_2    = list(shape = 2, rate = 1),#
    Lambda_df  =   3#
)
priors$tot_Y_prec_shape = with(priors$tot_Y_prec,nu-1)#
    priors$tot_Y_prec_rate = with(priors$tot_Y_prec,V*nu)#
    priors$tot_F_prec_shape = with(priors$tot_F_prec,nu-1)#
    priors$tot_F_prec_rate = with(priors$tot_F_prec,V*nu)
priors$tot_F_prec_shape
priors$tot_F_prec_rate
1*21/(21-2)
setwd("/Users/der7/Documents/Statistics/Sparse_factor_G_matrix/Correction/Analyses/Simulations")
library(parallel)#
library(Rcpp)#
library(Matrix)#
library(microbenchmark)#
compiler::enableJIT(3)#
# # compiler::setCompilerOptions(optimize=3)#
compiler::setCompilerOptions(suppressAll=TRUE)#
#
# setwd("~/Runcie Lab/SparseFactorMixedModel/R_BSFG")#
model_path = '~/Box Sync/DER_projects/BSFG/R_BSFG'#
# model_path = "/home/deruncie/projects/BSFG_Correction/software"#
# model_path = "~/Runcie Lab/SparseFactorMixedModel/R_BSFG"#
source(paste(model_path,'BSFG_discreteRandom_init.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
# source(paste(model_path,'BSFG_discreteRandom_sampler_2.R',sep='/'))#
# source(paste(model_path,'BSFG_discreteRandom_functions_v2.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
source(paste(model_path,'plotting_diagnostics.R',sep='/'))#
#
sourceCpp(paste(model_path,'BSFG_discreteRandom_functions_c.cpp',sep='/')) #,cacheDir = model_path
setwd('Sim_1')
# choose a seed for the random number generator. This can be a random seed (for analysis), or you can choose your seed so that #
# you can repeat the MCMC exactly#
seed = 1#
set.seed(seed)#
#
# create a folder for holding the posterior samples of the current chain (multiple folders could be used for different chains)#
rep = "3"#
folder = sprintf('R_rep_%s',rep)#
try(dir.create(folder))#
setwd(folder)#
# initialize priors#
run_parameters = list(#
    b0                 = 1,#
    b1                 = 0.0005,#
    epsilon            = 1e-1,#
    prop               = 1.00,#
    k_init             = 20,#
    discrete_divisions = 100,#
    burn               = 100,       #
    thin               = 2         #
    )#
#
priors = list(#
    tot_Y_prec = list(nu = 3.4, V = 1/3.5/3.4),#
    tot_F_prec = list(nu = 21,  V = 21/21),#
    delta_1    = list(nu = 3,   V = 1/20/3),#
    delta_2    = list(nu = 3,   V = 1/3),#
    Lambda_df  =   3#
)#
#
print('Initializing')#
setup = BSFG_discreteRandom_loadData()#
BSFG_state = with(setup,BSFG_discreteRandom_init(Y, ~1, ~Group,randomEffects,data,priors,run_parameters,scaleY = F,simulation = T))#
BSFG_state$run_parameters$setup = setup$setup#
#
library(MCMCpack)#
discrete_divisions = run_parameters$discrete_divisions#
BSFG_state$priors$Resid_discrete_priors = with(BSFG_state$data_matrices, sapply(1:ncol(h2_divisions),function(x) {#
    h2s = h2_divisions[,x]#
    pmax(pmin(ddirichlet(c(h2s,1-sum(h2s)),rep(2,length(h2s)+1)),10),1e-10)#
}))#
BSFG_state$priors$Resid_discrete_priors = BSFG_state$priors$Resid_discrete_priors/sum(BSFG_state$priors$Resid_discrete_priors)#
BSFG_state$priors$F_discrete_priors = c(discrete_divisions-1,rep(1,discrete_divisions-1))/(2*(discrete_divisions-1))
options(error=recover)
BSFG_state = with(setup,BSFG_discreteRandom_init(Y, ~1, ~Group,randomEffects,data,priors,run_parameters,scaleY = F,simulation = T))
ls()
priors
k = priors$k_init
with(priors,matrix(rgamma(p*k,shape = Lambda_df/2,rate = Lambda_df/2),nr = p,nc = k))
k = run_parameters$k_init
k
with(priors,matrix(rgamma(p*k,shape = Lambda_df/2,rate = Lambda_df/2),nr = p,nc = k))
Q
options(error=NULL)
library(parallel)#
library(Rcpp)#
library(Matrix)#
library(microbenchmark)#
compiler::enableJIT(3)#
# # compiler::setCompilerOptions(optimize=3)#
compiler::setCompilerOptions(suppressAll=TRUE)#
#
# setwd("~/Runcie Lab/SparseFactorMixedModel/R_BSFG")#
model_path = '~/Box Sync/DER_projects/BSFG/R_BSFG'#
# model_path = "/home/deruncie/projects/BSFG_Correction/software"#
# model_path = "~/Runcie Lab/SparseFactorMixedModel/R_BSFG"#
source(paste(model_path,'BSFG_discreteRandom_init.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
# source(paste(model_path,'BSFG_discreteRandom_sampler_2.R',sep='/'))#
# source(paste(model_path,'BSFG_discreteRandom_functions_v2.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
source(paste(model_path,'plotting_diagnostics.R',sep='/'))#
#
sourceCpp(paste(model_path,'BSFG_discreteRandom_functions_c.cpp',sep='/')) #,cacheDir = model_path
print('Initializing')#
setup = BSFG_discreteRandom_loadData()#
BSFG_state = with(setup,BSFG_discreteRandom_init(Y, ~1, ~Group,randomEffects,data,priors,run_parameters,scaleY = F,simulation = T))#
BSFG_state$run_parameters$setup = setup$setup
discrete_divisions = run_parameters$discrete_divisions#
BSFG_state$priors$Resid_discrete_priors = with(BSFG_state$data_matrices, sapply(1:ncol(h2_divisions),function(x) {#
    h2s = h2_divisions[,x]#
    pmax(pmin(ddirichlet(c(h2s,1-sum(h2s)),rep(2,length(h2s)+1)),10),1e-10)#
}))#
BSFG_state$priors$Resid_discrete_priors = BSFG_state$priors$Resid_discrete_priors/sum(BSFG_state$priors$Resid_discrete_priors)#
BSFG_state$priors$F_discrete_priors = c(discrete_divisions-1,rep(1,discrete_divisions-1))/(2*(discrete_divisions-1))#
#
# BSFG_state$priors$F_discrete_priors = with(BSFG_state$data_matrices, sapply(1:nrow(h2_divisions),function(x) {#
#     h2s = h2_divisions[x,]#
#     pmax(pmin(ddirichlet(c(h2s,1-sum(h2s)),rep(2,length(h2s)+1)),10),1e-10)#
# }))#
#
save(BSFG_state,file="BSFG_state.RData")#
#
BSFG_state = clear_Posterior(BSFG_state)#
# # optional: To load from end of previous run, run above code, then run these lines:#
# load('Posterior.RData')#
# load('BSFG_state.RData')#
# load('Priors.RData')#
#  BSFG_state$current_state = current_state#
#  BSFG_state$Posterior = Posterior#
#  BSFG_state$priors = priors#
# start_i = run_parameters$nrun;#
#
# Run Gibbs sampler. Run in smallish chunks. Output can be used to re-start chain where it left off.#
# burn in#
#
# if(run_parameters$burn > 0) BSFG_state = fast_BSFG_sampler(BSFG_state,run_parameters$burn)#
# BSFG_discreteRandom_sampler_2c = compiler::cmpfun(BSFG_discreteRandom_sampler)#
n_samples = 100;#
for(i  in 1:70) {#
    print(sprintf('Run %d',i))#
    # microbenchmark(#
    #     # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,8),#
    #     BSFG_discreteRandom_sampler(BSFG_state,n_samples,8),#
    #     # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,1),#
    #     BSFG_discreteRandom_sampler(BSFG_state,n_samples,1),#
    #     times = 10#
    #     )#
    # BSFG_state2 = BSFG_discreteRandom_sampler(BSFG_state,n_samples,8)#
    # BSFG_state2 = BSFG_discreteRandom_sampler_2c(BSFG_state,n_samples,8)#
    BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,8)#
    # BSFG_state2 = BSFG_discreteRandom_sampler_2c(BSFG_state,n_samples,1)#
    dev.set(6)#
    try({#
        par(mfrow=c(2,2))#
        plot(BSFG_state$Posterior$delta[1,],ylim = c(0,max(BSFG_state$Posterior$delta[1,])),type='l')#
        plot(BSFG_state$Posterior$delta[2,],ylim = c(0,max(BSFG_state$Posterior$delta[2,])),type='l')#
        plot(BSFG_state$Posterior$delta[3,],ylim = c(0,max(BSFG_state$Posterior$delta[3,])),type='l')#
    })#
    BSFG_state = reorder_factors(BSFG_state)#
    # if(BSFG_state$simulation) {#
        draw_simulation_diagnostics(BSFG_state)#
    # } else{#
    #     draw_results_diagnostics(BSFG_state)#
    # }#
    print(i)#
}
sample_MME_fixedEffects = function(Y,W,Sigma_Choleskys, Sigma_Perm, h2s_index, tot_Y_prec, prior_mean, prior_prec,ncores){#
    require(parallel)#
    # using method described in MCMC Course notes#
    p = ncol(Y)#
    n = nrow(Y)#
    b = ncol(W)#
    Wp = W#
    Yp = Y#
    if(!is.null(Sigma_Perm)) {#
        Wp = Sigma_Perm %*% W#
        Yp = Sigma_Perm %*% Y#
        Yp = matrix(Yp,nrow(Y))#
    }#
    recover()#
    res = mclapply(1:p,function(j) {#
        Cholesky_R = Sigma_Choleskys[[h2s_index[j]]]$Cholesky_Sigma#
        chol_R = Sigma_Choleskys[[h2s_index[j]]]$chol_Sigma#
        RinvSqW = solve(Cholesky_R,Wp,'L')#
        C = crossprod(RinvSqW) * tot_Y_prec[j]#
        diag(C) = diag(C) + prior_prec[,j]#
        theta_j = sample_MME_single_diagA(Y[,j], W, C, RinvSqW, prior_mean[,j],prior_prec[,j],Cholesky_R,chol_R,Sigma_Perm,tot_Y_prec[j])#
        theta_j#
    },mc.cores = ncores)#
    res = do.call(cbind,res)#
    res#
}
BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,8)
res = mclapply(1:p,function(j) {#
        Cholesky_R = Sigma_Choleskys[[h2s_index[j]]]$Cholesky_Sigma#
        chol_R = Sigma_Choleskys[[h2s_index[j]]]$chol_Sigma#
        RinvSqW = solve(Cholesky_R,Wp,'L')#
        C = crossprod(RinvSqW) * tot_Y_prec[j]#
        diag(C) = diag(C) + prior_prec[,j]#
        theta_j = sample_MME_single_diagA(Y[,j], W, C, RinvSqW, prior_mean[,j],prior_prec[,j],Cholesky_R,chol_R,Sigma_Perm,tot_Y_prec[j])#
        theta_j#
    },mc.cores = ncores)
res
res = do.call(cbind,res)
res
Q
sample_MME_fixedEffects = function(Y,W,Sigma_Choleskys, Sigma_Perm, h2s_index, tot_Y_prec, prior_mean, prior_prec,ncores){#
    require(parallel)#
    # using method described in MCMC Course notes#
    p = ncol(Y)#
    n = nrow(Y)#
    b = ncol(W)#
    Wp = W#
    Yp = Y#
    if(!is.null(Sigma_Perm)) {#
        Wp = Sigma_Perm %*% W#
        Yp = Sigma_Perm %*% Y#
        Yp = matrix(Yp,nrow(Y))#
    }#
    res = mclapply(1:p,function(j) {#
        Cholesky_R = Sigma_Choleskys[[h2s_index[j]]]$Cholesky_Sigma#
        chol_R = Sigma_Choleskys[[h2s_index[j]]]$chol_Sigma#
        RinvSqW = solve(Cholesky_R,Wp,'L')#
        C = crossprod(RinvSqW) * tot_Y_prec[j]#
        diag(C) = diag(C) + prior_prec[,j]#
        theta_j = sample_MME_single_diagA(Y[,j], W, C, RinvSqW, prior_mean[,j],prior_prec[,j],Cholesky_R,chol_R,Sigma_Perm,tot_Y_prec[j])#
        theta_j#
    },mc.cores = ncores)#
    res = do.call(cbind,res)#
    res#
}
options(error=recover)
BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,8)
coefs
Y
Design
resid_h2_index
tot_Y_prec
Q
library(parallel)#
library(Rcpp)#
library(Matrix)#
library(microbenchmark)#
library(MCMCpack)#
#
compiler::enableJIT(3)#
# # compiler::setCompilerOptions(optimize=3)#
compiler::setCompilerOptions(suppressAll=TRUE)#
#
# setwd("~/Runcie Lab/SparseFactorMixedModel/R_BSFG")#
model_path = '~/Box Sync/DER_projects/BSFG/R_BSFG'#
# model_path = "/home/deruncie/projects/BSFG_Correction/software"#
# model_path = "~/Runcie Lab/SparseFactorMixedModel/R_BSFG"#
source(paste(model_path,'BSFG_discreteRandom_init.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
# source(paste(model_path,'BSFG_discreteRandom_sampler_2.R',sep='/'))#
# source(paste(model_path,'BSFG_discreteRandom_functions_v2.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
source(paste(model_path,'plotting_diagnostics.R',sep='/'))#
#
sourceCpp(paste(model_path,'BSFG_discreteRandom_functions_c.cpp',sep='/')) #,cacheDir = model_path
# initialize priors#
run_parameters = list(#
    b0                 = 1,#
    b1                 = 0.0005,#
    epsilon            = 1e-1,#
    prop               = 1.00,#
    k_init             = 20,#
    discrete_divisions = 100,#
    burn               = 100,       #
    thin               = 2         #
    )#
#
priors = list(#
    tot_Y_var = list(nu = 3.4, V = 1/3.5/3.4),#
    tot_F_var = list(nu = 21,  V = 21/21),#
    delta_1    = list(nu = 3,   V = 1/20/3),#
    delta_2    = list(nu = 3,   V = 1/3),#
    Lambda_df  =   3#
)#
#
print('Initializing')#
setup = BSFG_discreteRandom_loadData()#
BSFG_state = with(setup,BSFG_discreteRandom_init(Y, ~1, ~Group,randomEffects,data,priors,run_parameters,scaleY = F,simulation = T))#
BSFG_state$run_parameters$setup = setup$setup#
#
discrete_divisions = run_parameters$discrete_divisions#
BSFG_state$priors$Resid_discrete_priors = with(BSFG_state$data_matrices, sapply(1:ncol(h2_divisions),function(x) {#
    h2s = h2_divisions[,x]#
    pmax(pmin(ddirichlet(c(h2s,1-sum(h2s)),rep(2,length(h2s)+1)),10),1e-10)#
}))#
BSFG_state$priors$Resid_discrete_priors = BSFG_state$priors$Resid_discrete_priors/sum(BSFG_state$priors$Resid_discrete_priors)#
BSFG_state$priors$F_discrete_priors = c(discrete_divisions-1,rep(1,discrete_divisions-1))/(2*(discrete_divisions-1))#
#
# BSFG_state$priors$F_discrete_priors = with(BSFG_state$data_matrices, sapply(1:nrow(h2_divisions),function(x) {#
#     h2s = h2_divisions[x,]#
#     pmax(pmin(ddirichlet(c(h2s,1-sum(h2s)),rep(2,length(h2s)+1)),10),1e-10)#
# }))#
#
save(BSFG_state,file="BSFG_state.RData")#
#
BSFG_state = clear_Posterior(BSFG_state)#
# # optional: To load from end of previous run, run above code, then run these lines:#
# load('Posterior.RData')#
# load('BSFG_state.RData')#
# load('Priors.RData')#
#  BSFG_state$current_state = current_state#
#  BSFG_state$Posterior = Posterior#
#  BSFG_state$priors = priors#
# start_i = run_parameters$nrun;#
#
# Run Gibbs sampler. Run in smallish chunks. Output can be used to re-start chain where it left off.#
# burn in#
#
# if(run_parameters$burn > 0) BSFG_state = fast_BSFG_sampler(BSFG_state,run_parameters$burn)#
# BSFG_discreteRandom_sampler_2c = compiler::cmpfun(BSFG_discreteRandom_sampler)#
n_samples = 100;#
for(i  in 1:70) {#
    print(sprintf('Run %d',i))#
    # microbenchmark(#
    #     # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,8),#
    #     BSFG_discreteRandom_sampler(BSFG_state,n_samples,8),#
    #     # BSFG_discreteRandom_sampler_2(BSFG_state,n_samples,1),#
    #     BSFG_discreteRandom_sampler(BSFG_state,n_samples,1),#
    #     times = 10#
    #     )#
    # BSFG_state2 = BSFG_discreteRandom_sampler(BSFG_state,n_samples,8)#
    # BSFG_state2 = BSFG_discreteRandom_sampler_2c(BSFG_state,n_samples,8)#
    BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,8)#
    # BSFG_state2 = BSFG_discreteRandom_sampler_2c(BSFG_state,n_samples,1)#
    dev.set(6)#
    try({#
        par(mfrow=c(2,2))#
        plot(BSFG_state$Posterior$delta[1,],ylim = c(0,max(BSFG_state$Posterior$delta[1,])),type='l')#
        plot(BSFG_state$Posterior$delta[2,],ylim = c(0,max(BSFG_state$Posterior$delta[2,])),type='l')#
        plot(BSFG_state$Posterior$delta[3,],ylim = c(0,max(BSFG_state$Posterior$delta[3,])),type='l')#
    })#
    BSFG_state = reorder_factors(BSFG_state)#
    # if(BSFG_state$simulation) {#
        draw_simulation_diagnostics(BSFG_state)#
    # } else{#
    #     draw_results_diagnostics(BSFG_state)#
    # }#
    print(i)#
}
41/20
1/3.5+2
2.4/2.3
detectCores()
priors = list(#
    tot_Y_var = list(V = 0.5, nu = 3),#
    tot_F_var = list(V = 18/20,  nu = 20),#
    delta_1    = list(V = 1/20,   nu = 3),#
    delta_2    = list(V = 1,   nu = 3),#
    Lambda_df  =   3#
)#
#
print('Initializing')#
setup = BSFG_discreteRandom_loadData()#
BSFG_state = with(setup,BSFG_discreteRandom_init(Y, ~1, ~Group,randomEffects,data,priors,run_parameters,scaleY = F,simulation = T))#
BSFG_state$run_parameters$setup = setup$setup#
#
discrete_divisions = run_parameters$discrete_divisions#
BSFG_state$priors$Resid_discrete_priors = with(BSFG_state$data_matrices, sapply(1:ncol(h2_divisions),function(x) {#
    h2s = h2_divisions[,x]#
    pmax(pmin(ddirichlet(c(h2s,1-sum(h2s)),rep(2,length(h2s)+1)),10),1e-10)#
}))#
BSFG_state$priors$Resid_discrete_priors = BSFG_state$priors$Resid_discrete_priors/sum(BSFG_state$priors$Resid_discrete_priors)#
BSFG_state$priors$F_discrete_priors = c(discrete_divisions-1,rep(1,discrete_divisions-1))/(2*(discrete_divisions-1))#
#
# BSFG_state$priors$F_discrete_priors = with(BSFG_state$data_matrices, sapply(1:nrow(h2_divisions),function(x) {#
#     h2s = h2_divisions[x,]#
#     pmax(pmin(ddirichlet(c(h2s,1-sum(h2s)),rep(2,length(h2s)+1)),10),1e-10)#
# }))#
#
save(BSFG_state,file="BSFG_state.RData")#
#
BSFG_state = clear_Posterior(BSFG_state)#
# # optional: To load from end of previous run, run above code, then run these lines:#
# load('Posterior.RData')#
# load('BSFG_state.RData')#
# load('Priors.RData')#
#  BSFG_state$current_state = current_state#
#  BSFG_state$Posterior = Posterior#
#  BSFG_state$priors = priors#
# start_i = run_parameters$nrun;#
#
# Run Gibbs sampler. Run in smallish chunks. Output can be used to re-start chain where it left off.#
# burn in#
#
# if(run_parameters$burn > 0) BSFG_state = fast_BSFG_sampler(BSFG_state,run_parameters$burn)#
# BSFG_discreteRandom_sampler_2c = compiler::cmpfun(BSFG_discreteRandom_sampler)#
n_samples = 100;#
for(i  in 1:70) {#
    print(sprintf('Run %d',i))#
    # microbenchmark(#
    #     BSFG_discreteRandom_sampler(BSFG_state,2,detectCores()),#
    #     BSFG_discreteRandom_sampler(BSFG_state,2,1),#
    #     times = 10#
    #     )#
    BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,1)#
    # BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,detectCores())#
    dev.set(6)#
    try({#
        par(mfrow=c(2,2))#
        plot(BSFG_state$Posterior$delta[1,],ylim = c(0,max(BSFG_state$Posterior$delta[1,])),type='l')#
        plot(BSFG_state$Posterior$delta[2,],ylim = c(0,max(BSFG_state$Posterior$delta[2,])),type='l')#
        plot(BSFG_state$Posterior$delta[3,],ylim = c(0,max(BSFG_state$Posterior$delta[3,])),type='l')#
    })#
    BSFG_state = reorder_factors(BSFG_state)#
    # if(BSFG_state$simulation) {#
        draw_simulation_diagnostics(BSFG_state)#
    # } else{#
    #     draw_results_diagnostics(BSFG_state)#
    # }#
    print(i)#
}
library(parallel)#
library(Rcpp)#
library(Matrix)#
library(microbenchmark)#
library(MCMCpack)#
#
compiler::enableJIT(3)#
# # compiler::setCompilerOptions(optimize=3)#
compiler::setCompilerOptions(suppressAll=TRUE)#
#
# setwd("~/Runcie Lab/SparseFactorMixedModel/R_BSFG")#
model_path = '~/Box Sync/DER_projects/BSFG/R_BSFG'#
# model_path = "/home/deruncie/projects/BSFG_Correction/software"#
# model_path = "~/Runcie Lab/SparseFactorMixedModel/R_BSFG"#
source(paste(model_path,'BSFG_discreteRandom_init.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
# source(paste(model_path,'BSFG_discreteRandom_sampler_2.R',sep='/'))#
# source(paste(model_path,'BSFG_discreteRandom_functions_v2.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
source(paste(model_path,'plotting_diagnostics.R',sep='/'))#
#
sourceCpp(paste(model_path,'BSFG_discreteRandom_functions_c.cpp',sep='/')) #,cacheDir = model_path
BSFG_state = clear_Posterior(BSFG_state)#
# # optional: To load from end of previous run, run above code, then run these lines:#
# load('Posterior.RData')#
# load('BSFG_state.RData')#
# load('Priors.RData')#
#  BSFG_state$current_state = current_state#
#  BSFG_state$Posterior = Posterior#
#  BSFG_state$priors = priors#
# start_i = run_parameters$nrun;#
#
# Run Gibbs sampler. Run in smallish chunks. Output can be used to re-start chain where it left off.#
# burn in#
#
# if(run_parameters$burn > 0) BSFG_state = fast_BSFG_sampler(BSFG_state,run_parameters$burn)#
# BSFG_discreteRandom_sampler_2c = compiler::cmpfun(BSFG_discreteRandom_sampler)#
n_samples = 100;#
for(i  in 1:70) {#
    print(sprintf('Run %d',i))#
    # microbenchmark(#
    #     BSFG_discreteRandom_sampler(BSFG_state,2,detectCores()),#
    #     BSFG_discreteRandom_sampler(BSFG_state,2,1),#
    #     times = 10#
    #     )#
    BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,1)#
    # BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,detectCores())#
    dev.set(6)#
    try({#
        par(mfrow=c(2,2))#
        plot(BSFG_state$Posterior$delta[1,],ylim = c(0,max(BSFG_state$Posterior$delta[1,])),type='l')#
        plot(BSFG_state$Posterior$delta[2,],ylim = c(0,max(BSFG_state$Posterior$delta[2,])),type='l')#
        plot(BSFG_state$Posterior$delta[3,],ylim = c(0,max(BSFG_state$Posterior$delta[3,])),type='l')#
    })#
    BSFG_state = reorder_factors(BSFG_state)#
    # if(BSFG_state$simulation) {#
        draw_simulation_diagnostics(BSFG_state)#
    # } else{#
    #     draw_results_diagnostics(BSFG_state)#
    # }#
    print(i)#
}
F = sample_factors_scores_sparse_c( Y_tilde, Z_all,Lambda,resid_Y_prec,F_a,F_e_prec )
is(Y_tilde)
Y_tilde
Z_all
Lambda
resid_Y_prec
F_a
is(F_a)
sample_MME_multiple_diagR = function(Y,W,Cholesky_C,pe,chol_A_inv,tot_Y_prec){#
    n = nrow(Y)#
    p = ncol(Y)#
    n_theta = nrow(chol_A_inv)#
    theta_star = solve(chol_A_inv,matrix(rnorm(n_theta*p),ncol = p))#
    # theta_star = matrix(theta_star@x,ncol = p) + prior_mean#
    e_star = matrix(rnorm(n*p)/sqrt(pe),ncol = p,byrow=T)#
    W_theta_star = W %*% theta_star#
    Y_resid = Y - W_theta_star@x - e_star#
    WtRiy = crossprod(W,sweep(Y_resid,2,pe,'*'))#
#
    theta_tilda = solve(Cholesky_C,WtRiy)#
#
    theta = sweep(matrix(theta_tilda@x,nc=p),2,tot_Y_prec,'/') + theta_star#
    recover()#
    return(theta)#
}
E_a = sample_MME_ZAZts(Y_tilde, Z_all, tot_Y_prec, randomEffect_C_Choleskys, resid_h2, resid_h2_index,chol_Ai_mats,ncores)
sample_MME_multiple_diagR = function(Y,W,Cholesky_C,pe,chol_A_inv,tot_Y_prec){#
    n = nrow(Y)#
    p = ncol(Y)#
    n_theta = nrow(chol_A_inv)#
    theta_star = solve(chol_A_inv,matrix(rnorm(n_theta*p),ncol = p))#
    # theta_star = matrix(theta_star@x,ncol = p) + prior_mean#
    e_star = matrix(rnorm(n*p)/sqrt(pe),ncol = p,byrow=T)#
    W_theta_star = W %*% theta_star#
    Y_resid = Y - W_theta_star@x - e_star#
    WtRiy = crossprod(W,sweep(Y_resid,2,pe,'*'))#
#
    theta_tilda = solve(Cholesky_C,WtRiy)#
#
    theta = sweep(matrix(theta_tilda@x,nc=p),2,tot_Y_prec,'/') + theta_star#
    recover()#
    return(theta)#
}
sample_MME_ZAZts = function(Y, W, tot_Y_prec, randomEffect_C_Choleskys, h2s, h2s_index, chol_Ai_mats,ncores){#
    # using method described in MCMC Course notes#
    require(parallel)#
    Y = as.matrix(Y)#
    p = ncol(Y)#
    n = nrow(Y)#
    b = ncol(W)#
    pes = tot_Y_prec / (1-colSums(h2s))#
#
    unique_h2s = unique(h2s_index)#
    unique_h2s_index = sapply(unique_h2s,function(x) which(h2s_index == x)) #
    thetas = mclapply(seq_along(unique_h2s),function(j){#
        Cholesky_C = randomEffect_C_Choleskys[[unique_h2s[j]]]$Cholesky_C#
        chol_A_inv = randomEffect_C_Choleskys[[unique_h2s[j]]]$chol_A_inv * sqrt(tot_Y_prec[j])#
        traits_j = unique_h2s_index[[j]]#
        sample_MME_multiple_diagR(as.matrix(Y[,traits_j,drop=F]), W, Cholesky_C, pes[traits_j], chol_A_inv,tot_Y_prec[traits_j])        #
    },mc.cores = ncores)#
    theta = do.call(cbind,thetas)#
    theta = theta[,order(unlist(unique_h2s_index))]#
    theta#
}
sample_MME_ZAZts = compiler::cmpfun(sample_MME_ZAZts)
E_a = sample_MME_ZAZts(Y_tilde, Z_all, tot_Y_prec, randomEffect_C_Choleskys, resid_h2, resid_h2_index,chol_Ai_mats,ncores)
n = nrow(Y)
p = ncol(Y)
n_theta = nrow(chol_A_inv)
theta_star = solve(chol_A_inv,matrix(rnorm(n_theta*p),ncol = p))
theta_star
is(theta_star)
dim(theta_star)
e_star = matrix(rnorm(n*p)/sqrt(pe),ncol = p,byrow=T)
W_theta_star = W %*% theta_star
is(W_theta_star)
theta_star = matrix(theta_star@x,ncol = p)
W_theta_star = W %*% theta_star
is(W_theta_star)
is(W)
theta_star = solve(chol_A_inv,matrix(rnorm(n_theta*p),ncol = p))
# theta_star = matrix(theta_star@x,ncol = p) + prior_mean
e_star = matrix(rnorm(n*p)/sqrt(pe),ncol = p,byrow=T)
W_theta_star = W %*% theta_star
Y_resid = Y - W_theta_star@x - e_star
WtRiy = crossprod(W,sweep(Y_resid,2,pe,'*'))
theta_tilda = solve(Cholesky_C,WtRiy)
is(Y)
is(e_star)
is(theta_tilda)
theta = sweep(matrix(theta_tilda@x,nc=p),2,tot_Y_prec,'/') + theta_star
is(theta)
theta_star
is(theta_star)
theta2 = sweep(matrix(theta_tilda@x,nc=p),2,tot_Y_prec,'/') + theta_star@x
dim(theta)
dim(theta2)
microbenchmark(#
    theta <-sweep(matrix(theta_tilda@x,nc=p),2,tot_Y_prec,'/') + theta_star,#
    theta2 <-sweep(matrix(theta_tilda@x,nc=p),2,tot_Y_prec,'/') + theta_star@x#
)
theta-theta2
0
0
sample_MME_multiple_diagR = function(Y,W,Cholesky_C,pe,chol_A_inv,tot_Y_prec){#
    n = nrow(Y)#
    p = ncol(Y)#
    n_theta = nrow(chol_A_inv)#
    theta_star = solve(chol_A_inv,matrix(rnorm(n_theta*p),ncol = p))#
    # theta_star = matrix(theta_star@x,ncol = p) + prior_mean#
    e_star = matrix(rnorm(n*p)/sqrt(pe),ncol = p,byrow=T)#
    W_theta_star = W %*% theta_star#
    Y_resid = Y - W_theta_star@x - e_star#
    WtRiy = crossprod(W,sweep(Y_resid,2,pe,'*'))#
#
    theta_tilda = solve(Cholesky_C,WtRiy)#
#
    theta = sweep(matrix(theta_tilda@x,nc=p),2,tot_Y_prec,'/') + theta_star@x#
#
    return(theta)#
}
BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,1)
library(parallel)#
library(Rcpp)#
library(Matrix)#
library(microbenchmark)#
library(MCMCpack)#
#
compiler::enableJIT(3)#
# # compiler::setCompilerOptions(optimize=3)#
compiler::setCompilerOptions(suppressAll=TRUE)#
#
# setwd("~/Runcie Lab/SparseFactorMixedModel/R_BSFG")#
model_path = '~/Box Sync/DER_projects/BSFG/R_BSFG'#
# model_path = "/home/deruncie/projects/BSFG_Correction/software"#
# model_path = "~/Runcie Lab/SparseFactorMixedModel/R_BSFG"#
source(paste(model_path,'BSFG_discreteRandom_init.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
source(paste(model_path,'plotting_diagnostics.R',sep='/'))#
#
sourceCpp(paste(model_path,'BSFG_discreteRandom_functions_c.cpp',sep='/')) #,cacheDir = model_path
library(parallel)#
library(Rcpp)#
library(Matrix)#
library(microbenchmark)#
library(MCMCpack)#
#
compiler::enableJIT(3)#
# # compiler::setCompilerOptions(optimize=3)#
compiler::setCompilerOptions(suppressAll=TRUE)#
#
# setwd("~/Runcie Lab/SparseFactorMixedModel/R_BSFG")#
model_path = '~/Box Sync/DER_projects/BSFG/R_BSFG'#
# model_path = "/home/deruncie/projects/BSFG_Correction/software"#
# model_path = "~/Runcie Lab/SparseFactorMixedModel/R_BSFG"#
source(paste(model_path,'BSFG_discreteRandom_init.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
source(paste(model_path,'plotting_diagnostics.R',sep='/'))#
#
sourceCpp(paste(model_path,'BSFG_discreteRandom_functions_c.cpp',sep='/')) #,cacheDir = model_path
library(parallel)#
library(Rcpp)#
library(Matrix)#
library(microbenchmark)#
library(MCMCpack)#
#
compiler::enableJIT(3)#
# # compiler::setCompilerOptions(optimize=3)#
compiler::setCompilerOptions(suppressAll=TRUE)#
#
# setwd("~/Runcie Lab/SparseFactorMixedModel/R_BSFG")#
model_path = '~/Box Sync/DER_projects/BSFG/R_BSFG'#
# model_path = "/home/deruncie/projects/BSFG_Correction/software"#
# model_path = "~/Runcie Lab/SparseFactorMixedModel/R_BSFG"#
source(paste(model_path,'BSFG_discreteRandom_init.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
source(paste(model_path,'plotting_diagnostics.R',sep='/'))#
#
sourceCpp(paste(model_path,'BSFG_discreteRandom_functions_c.cpp',sep='/')) #,cacheDir = model_path
library(parallel)#
library(Rcpp)#
library(Matrix)#
library(microbenchmark)#
library(MCMCpack)#
#
compiler::enableJIT(3)#
# # compiler::setCompilerOptions(optimize=3)#
compiler::setCompilerOptions(suppressAll=TRUE)#
#
# setwd("~/Runcie Lab/SparseFactorMixedModel/R_BSFG")#
model_path = '~/Box Sync/DER_projects/BSFG/R_BSFG'#
# model_path = "/home/deruncie/projects/BSFG_Correction/software"#
# model_path = "~/Runcie Lab/SparseFactorMixedModel/R_BSFG"#
source(paste(model_path,'BSFG_discreteRandom_init.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
source(paste(model_path,'plotting_diagnostics.R',sep='/'))#
#
sourceCpp(paste(model_path,'BSFG_discreteRandom_functions_c.cpp',sep='/')) #,cacheDir = model_path
print('Initializing')#
setup = BSFG_discreteRandom_loadData()#
BSFG_state = with(setup,BSFG_discreteRandom_init(Y, ~1, ~Group,A_inv_mats = randomEffects,data,priors,run_parameters,scaleY = F,simulation = T))#
BSFG_state$run_parameters$setup = setup$setup
A_mats
length(A_mats)
names(A_mats)
RE_names
rm(A_mats)
re = RE_names[1]
re
re %in% names(A_mats)
re %in% names(A_inv_mats)
A = solve(A_inv_mats[[re]])
dim(A)
is(A)
index = match(sub(re,'',colnames(Z_matrices[[re]])),rownames(A))  # A must have rownames
index
rownames(A)
colnames(A)
rownames(A) = rownames(A_inv_mats[[re]])
match(sub(re,'',colnames(Z_matrices[[re]])),rownames(A))  # A must have rownames
rownames(A_inv_mats[[re]])
rownames(A) = rownames(A_inv_mats[[re]])
sub(re,'',colnames(Z_matrices[[re]]))
colnames(Z_matrices[[re]])
Z_matrices[[re]]
re
Z_matrices
names(Z_matrices)
ls()
Q
library(parallel)#
library(Rcpp)#
library(Matrix)#
library(microbenchmark)#
library(MCMCpack)#
#
compiler::enableJIT(3)#
# # compiler::setCompilerOptions(optimize=3)#
compiler::setCompilerOptions(suppressAll=TRUE)#
#
# setwd("~/Runcie Lab/SparseFactorMixedModel/R_BSFG")#
model_path = '~/Box Sync/DER_projects/BSFG/R_BSFG'#
# model_path = "/home/deruncie/projects/BSFG_Correction/software"#
# model_path = "~/Runcie Lab/SparseFactorMixedModel/R_BSFG"#
source(paste(model_path,'BSFG_discreteRandom_init.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
source(paste(model_path,'plotting_diagnostics.R',sep='/'))#
#
sourceCpp(paste(model_path,'BSFG_discreteRandom_functions_c.cpp',sep='/')) #,cacheDir = model_path
setup = BSFG_discreteRandom_loadData()
BSFG_state = with(setup,BSFG_discreteRandom_init(Y, ~1, ~Group,A_inv_mats = randomEffects,data,priors,run_parameters,scaleY = F,simulation = T))
n = nrow(Y)
p = ncol(Y)
traitnames = colnames(Y)
Y_missing = is.na(Y)
if(scaleY){#
        Mean_Y = colMeans(Y,na.rm=T)#
        VY = apply(Y,2,var,na.rm=T)#
        Y = sweep(Y,2,Mean_Y,'-')#
        Y = sweep(Y,2,sqrt(VY),'/')#
    } else {#
        Mean_Y = rep(0,p)#
        VY = rep(1,p)#
    }
X = model.matrix(fixed,data)
b = ncol(X)
RE_names = rownames(attr(terms(random),'factors'))
n_RE = length(RE_names)
Z_matrices = lapply(RE_names,function(re) {#
        Z = Matrix(model.matrix(formula(sprintf('~0 + %s',re)),data),sparse = TRUE)#
        Z[,paste0(re,levels(data[[re]]))]#
    })
head(data)
Q
library(parallel)#
library(Rcpp)#
library(Matrix)#
library(microbenchmark)#
library(MCMCpack)#
#
compiler::enableJIT(3)#
# # compiler::setCompilerOptions(optimize=3)#
compiler::setCompilerOptions(suppressAll=TRUE)#
#
# setwd("~/Runcie Lab/SparseFactorMixedModel/R_BSFG")#
model_path = '~/Box Sync/DER_projects/BSFG/R_BSFG'#
# model_path = "/home/deruncie/projects/BSFG_Correction/software"#
# model_path = "~/Runcie Lab/SparseFactorMixedModel/R_BSFG"#
source(paste(model_path,'BSFG_discreteRandom_init.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
source(paste(model_path,'plotting_diagnostics.R',sep='/'))#
#
sourceCpp(paste(model_path,'BSFG_discreteRandom_functions_c.cpp',sep='/')) #,cacheDir = model_path
library(parallel)#
library(Rcpp)#
library(Matrix)#
library(microbenchmark)#
library(MCMCpack)#
#
compiler::enableJIT(3)#
# # compiler::setCompilerOptions(optimize=3)#
compiler::setCompilerOptions(suppressAll=TRUE)#
#
# setwd("~/Runcie Lab/SparseFactorMixedModel/R_BSFG")#
model_path = '~/Box Sync/DER_projects/BSFG/R_BSFG'#
# model_path = "/home/deruncie/projects/BSFG_Correction/software"#
# model_path = "~/Runcie Lab/SparseFactorMixedModel/R_BSFG"#
source(paste(model_path,'BSFG_discreteRandom_init.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_sampler.R',sep='/'))#
source(paste(model_path,'BSFG_discreteRandom_functions.R',sep='/'))#
source(paste(model_path,'plotting_diagnostics.R',sep='/'))#
#
sourceCpp(paste(model_path,'BSFG_discreteRandom_functions_c.cpp',sep='/')) #,cacheDir = model_path
print('Initializing')#
setup = BSFG_discreteRandom_loadData()#
BSFG_state = with(setup,BSFG_discreteRandom_init(Y, ~1, ~Group,data,priors,run_parameters,A_inv_mats = randomEffects,scaleY = F,simulation = T))#
BSFG_state$run_parameters$setup = setup$setup
discrete_divisions = run_parameters$discrete_divisions#
BSFG_state$priors$Resid_discrete_priors = with(BSFG_state$data_matrices, sapply(1:ncol(h2_divisions),function(x) {#
    h2s = h2_divisions[,x]#
    pmax(pmin(ddirichlet(c(h2s,1-sum(h2s)),rep(2,length(h2s)+1)),10),1e-10)#
}))#
BSFG_state$priors$Resid_discrete_priors = BSFG_state$priors$Resid_discrete_priors/sum(BSFG_state$priors$Resid_discrete_priors)#
BSFG_state$priors$F_discrete_priors = c(discrete_divisions-1,rep(1,discrete_divisions-1))/(2*(discrete_divisions-1))#
#
# BSFG_state$priors$F_discrete_priors = with(BSFG_state$data_matrices, sapply(1:nrow(h2_divisions),function(x) {#
#     h2s = h2_divisions[x,]#
#     pmax(pmin(ddirichlet(c(h2s,1-sum(h2s)),rep(2,length(h2s)+1)),10),1e-10)#
# }))#
#
save(BSFG_state,file="BSFG_state.RData")#
#
BSFG_state = clear_Posterior(BSFG_state)#
# # optional: To load from end of previous run, run above code, then run these lines:#
# load('Posterior.RData')#
# load('BSFG_state.RData')#
# load('Priors.RData')#
#  BSFG_state$current_state = current_state#
#  BSFG_state$Posterior = Posterior#
#  BSFG_state$priors = priors#
# start_i = run_parameters$nrun;#
#
# Run Gibbs sampler. Run in smallish chunks. Output can be used to re-start chain where it left off.#
# burn in#
#
# if(run_parameters$burn > 0) BSFG_state = fast_BSFG_sampler(BSFG_state,run_parameters$burn)#
# BSFG_discreteRandom_sampler_2c = compiler::cmpfun(BSFG_discreteRandom_sampler)#
n_samples = 100;#
for(i  in 1:70) {#
    print(sprintf('Run %d',i))#
    # microbenchmark(#
    #     BSFG_discreteRandom_sampler(BSFG_state,2,detectCores()),#
    #     BSFG_discreteRandom_sampler(BSFG_state,2,1),#
    #     times = 10#
    #     )#
    BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,1)#
    # BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,detectCores())#
    dev.set(6)#
    try({#
        par(mfrow=c(2,2))#
        plot(BSFG_state$Posterior$delta[1,],ylim = c(0,max(BSFG_state$Posterior$delta[1,])),type='l')#
        plot(BSFG_state$Posterior$delta[2,],ylim = c(0,max(BSFG_state$Posterior$delta[2,])),type='l')#
        plot(BSFG_state$Posterior$delta[3,],ylim = c(0,max(BSFG_state$Posterior$delta[3,])),type='l')#
    })#
    BSFG_state = reorder_factors(BSFG_state)#
    # if(BSFG_state$simulation) {#
        draw_simulation_diagnostics(BSFG_state)#
    # } else{#
    #     draw_results_diagnostics(BSFG_state)#
    # }#
    print(i)#
}
BSFG_state = clear_Posterior(BSFG_state)#
# # optional: To load from end of previous run, run above code, then run these lines:#
# load('Posterior.RData')#
# load('BSFG_state.RData')#
# load('Priors.RData')#
#  BSFG_state$current_state = current_state#
#  BSFG_state$Posterior = Posterior#
#  BSFG_state$priors = priors#
# start_i = run_parameters$nrun;#
#
# Run Gibbs sampler. Run in smallish chunks. Output can be used to re-start chain where it left off.#
# burn in#
#
# if(run_parameters$burn > 0) BSFG_state = fast_BSFG_sampler(BSFG_state,run_parameters$burn)#
# BSFG_discreteRandom_sampler_2c = compiler::cmpfun(BSFG_discreteRandom_sampler)#
n_samples = 100;#
for(i  in 1:70) {#
    print(sprintf('Run %d',i))#
    # microbenchmark(#
    #     BSFG_discreteRandom_sampler(BSFG_state,2,detectCores()),#
    #     BSFG_discreteRandom_sampler(BSFG_state,2,1),#
    #     times = 10#
    #     )#
    BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,1)#
    # BSFG_state = BSFG_discreteRandom_sampler(BSFG_state,n_samples,detectCores())#
    dev.set(6)#
    try({#
        par(mfrow=c(2,2))#
        plot(BSFG_state$Posterior$delta[1,],ylim = c(0,max(BSFG_state$Posterior$delta[1,])),type='l')#
        plot(BSFG_state$Posterior$delta[2,],ylim = c(0,max(BSFG_state$Posterior$delta[2,])),type='l')#
        plot(BSFG_state$Posterior$delta[3,],ylim = c(0,max(BSFG_state$Posterior$delta[3,])),type='l')#
    })#
    BSFG_state = reorder_factors(BSFG_state)#
    # if(BSFG_state$simulation) {#
        draw_simulation_diagnostics(BSFG_state)#
    # } else{#
    #     draw_results_diagnostics(BSFG_state)#
    # }#
    print(i)#
}
discrete_divisions = 15#
priors = list(#
    tot_Y_var      =   list(V = 1, nu = 3)#
)#
priors$tot_Y_prec_shape = with(priors$tot_Y_var,V * nu)#
priors$tot_Y_prec_rate  = with(priors$tot_Y_var,nu - 2)
priors
y = rgamma(1e5,shape=2.4,rate=1/3.5)
mean(1/y)
g = rinvgamma(1e5,shape=2,scale=1)
r = rinvgamma(1e5,shape=2,scale=1)
mean(sum(g,r))
mean(g+r)
mean(g)
mean(r)
mean(g+r)
yp = rgamma(1e5,shape=3,rate=1)
mean(1/yp)
quartz()
qqplot(1/yp,g+r)
g = rinvgamma(1e4,shape=2,scale=1)
4 = rinvgamma(1e4,shape=2,scale=1)
r = rinvgamma(1e4,shape=2,scale=1)
yp = rgamma(1e3,shape=3,rate=2)
mean(1/yp)
yp = rgamma(1e3,shape=3,rate=3)
mean(1/yp)
qqplot(1/yp,g+r)
ablin(0,1)
abline(0,1)
yp = rgamma(1e3,shape=2,rate=2)
mean(1/yp)
qqplot(1/yp,g+r)
abline(0,1)
setwd("/Users/der7/Box Sync/DER_projects/BSFG/test_MM")
## This seems to be working now, with a decent speed up#
## It is all implemented using the perm-reducing re-ordering, which gives a good speed up to the fixed_effect sampling, #
##    and moderate speed-ups to the other two steps.#
## potentially strange results with limited discritization#
#
library(MCMCglmm)#
source('../R_BSFG/BSFG_discreteRandom_functions.R')#
Data <- as.data.frame(read.table(file = "./gryphon.dat", header = TRUE))#
names(Data)[1] <- "animal"#
Data$animal <- as.factor(Data$animal)#
Data$MOTHER <- as.factor(Data$MOTHER)#
Data$BYEAR <- as.factor(Data$BYEAR)#
Data$SEX <- as.factor(Data$SEX)#
Data$BWT <- as.numeric(Data$BWT)#
Data$TARSUS <- as.numeric(Data$TARSUS)#
head(Data)#
Ped <- as.data.frame(read.table(file = "./gryphon.ped", header = TRUE))#
for (x in 1:3) Ped[, x] <- as.factor(Ped[, x])#
head(Ped)#
#
# Data$BWT = matrix(rnorm(nrow(Data),0,sd(Data$BWT,na.rm=T)),nc=1)
prior1.3 <- list(G = list(G1 = list(V = 1, n = 0.002), G2 = list(V = 1,n = 0.002)), R = list(V = 1, n = 0.002))#
prior1.3 = list(R = list(V = 1/3, nu = 3), G = list(G1 = list(V = 1/3,nu=3),G2 = list(V = 1/3,nu=3)))#
model1.3 <- MCMCglmm(BWT ~ SEX, random = ~animal + BYEAR, pedigree = Ped,#
    data = Data, nitt = 6500, thin = 5, burnin = 1500, prior = prior1.3,pr=T,#
    verbose = FALSE)#
posterior.mode(model1.3$VCV)#
#
mcmc_model = model1.3
